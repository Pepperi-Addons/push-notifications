"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IterableEndpoint = void 0;
class IterableEndpoint {
    constructor(service, endpoint) {
        this.service = service;
        this.endpoint = endpoint;
    }
    async find(options = {}) {
        let url = this.getEndpointURL();
        const query = Endpoint.encodeQueryParams(options);
        url = query ? url + '?' + query : url;
        return this.service.get(url);
    }
    getEndpointURL() {
        return this.endpoint;
    }
    iter(options = {}) {
        const self = this;
        return {
            [Symbol.asyncIterator]() {
                const newOptions = options;
                newOptions.include_count = true;
                let currentPage = 1;
                const pageSize = options.page_size || 100;
                let obj = { items: [], numOfPages: 1 };
                return {
                    next: async () => {
                        if (obj.items.length == 0) {
                            if (currentPage == 1) {
                                newOptions.page = currentPage++;
                                obj = await self.getFirstPage(newOptions);
                                obj.items = obj.items.reverse();
                                newOptions.include_count = false;
                                // this means there is no 'X-Pepperi-Total-Pages' header (eg. ADAL)
                                if (obj.numOfPages === 0) {
                                    // the items on first page are less than the page size
                                    // this means that there are no more pages
                                    if (obj.items.length < pageSize) {
                                        obj.numOfPages = 1;
                                    }
                                }
                            }
                            else if (obj.numOfPages === 0 || currentPage <= obj.numOfPages) {
                                newOptions.page = currentPage++;
                                obj.items = (await self.find(newOptions)).reverse();
                                if (obj.numOfPages === 0) {
                                    // we might have reached the end and don't want to call one extra time
                                    if (obj.items.length < pageSize) {
                                        obj.numOfPages = currentPage - 1;
                                    }
                                }
                            }
                        }
                        const retItem = obj.items.length > 0 ? obj.items.pop() : undefined;
                        if (retItem) {
                            return { value: retItem, done: false };
                        }
                        return { value: {}, done: true };
                    },
                };
            },
            toArray: async () => {
                var e_1, _a;
                const items = [];
                try {
                    for (var _b = __asyncValues(this.iter(options)), _c; _c = await _b.next(), !_c.done;) {
                        const item = _c.value;
                        items.push(item);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return items;
            },
        };
    }
    async getFirstPage(options) {
        let url = this.getEndpointURL();
        const query = Endpoint.encodeQueryParams(options);
        let items = [];
        url = query ? url + '?' + query : url;
        const res = await this.service.apiCall('GET', url);
        const numOfPages = Number(res.headers.get('X-Pepperi-Total-Pages'));
        items = await res.json();
        return { items, numOfPages };
    }
}
exports.IterableEndpoint = IterableEndpoint;
class Endpoint extends IterableEndpoint {
    constructor(service, endpoint) {
        super(service, endpoint);
        this.service = service;
        this.endpoint = endpoint;
    }
    async count(options = {}) {
        let url = '/totals';
        url += this.getEndpointURL();
        const query = Endpoint.encodeQueryParams(Object.assign({ select: 'count(InternalID) as count' }, options));
        url = query ? url + '?' + query : url;
        const countObject = await this.service.get(url);
        if (options.group_by) {
            // Return an object of 'group_by' values and 'count' values.
            const groupedCountObjects = {};
            countObject.forEach((item) => {
                groupedCountObjects[item[options.group_by || '']] = item['count'];
            });
            return groupedCountObjects;
        }
        else {
            // Returns just a number.
            return countObject && countObject.length == 1 ? countObject[0].count : 0;
        }
    }
    async get(id) {
        let url = this.getEndpointURL();
        url += '/' + id;
        return this.service.get(url);
    }
    async upsert(object) {
        return this.service.post(this.getEndpointURL(), object);
    }
    async batch(objects) {
        return this.service.post('/batch' + this.getEndpointURL(), objects);
    }
    async export(options) {
        const body = {
            fields: options.fields ? options.fields.join(',') : undefined,
            where: options.where,
            order_by: options.order_by,
            page: options.page,
            page_size: options.page_size,
            include_nested: options.include_nested,
            full_mode: options.full_mode,
            include_deleted: options.include_deleted,
            is_distinct: options.is_distinct,
        };
        return this.service.post('/export' + this.getEndpointURL(), body);
    }
    async delete(id) {
        let url = this.getEndpointURL();
        url += '/' + id;
        return this.service
            .delete(url)
            .then((res) => res.text())
            .then((res) => (res ? JSON.parse(res) : ''));
    }
    uuid(uuid) {
        const service = this.service;
        let url = this.getEndpointURL();
        url += '/uuid/' + uuid;
        return {
            get() {
                return service.get(url);
            },
        };
    }
    static encodeQueryParams(params) {
        const ret = [];
        Object.keys(params).forEach((key) => {
            ret.push(key + '=' + encodeURIComponent(params[key]));
        });
        return ret.join('&');
    }
}
exports.default = Endpoint;
