"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLWhereParser = void 0;
const parser_1 = __importDefault(require("./parser"));
const converters_1 = require("./converters");
class SQLWhereParser {
    constructor(fields) {
        this.fields = fields;
    }
    /**
     * Parse a SQL where clause into a JSON Filter
     * @param where An SQL style WHERE clause
     */
    parse(where) {
        const ast = parser_1.default(where);
        return this.parseNode(ast);
    }
    parseNode(node) {
        if (node.AND) {
            return {
                Operation: 'AND',
                LeftNode: this.parseNode(node.AND[0]),
                RightNode: this.parseNode(node.AND[1]),
            };
        }
        else if (node.OR) {
            return {
                Operation: 'OR',
                LeftNode: this.parseNode(node.OR[0]),
                RightNode: this.parseNode(node.OR[1]),
            };
        }
        else {
            return this.parseExpression(node);
        }
    }
    parseExpression(expression) {
        let operation = Object.keys(expression)[0];
        // NOT IN
        if (operation === 'IN' &&
            typeof expression[operation][0] === 'object' &&
            Object.keys(expression[operation][0])[0] === 'NOT') {
            expression = {
                'NOT IN': [expression[operation][0].NOT[0], expression[operation][1]],
            };
            operation = 'NOT IN';
        }
        // We only support where clauses that the ApiName is on the left side of each operation
        const apiName = expression[operation][0];
        if (!apiName) {
            throw new Error("Left side isn't an FieldName");
        }
        // make sure this field is registered
        const fieldType = this.fields[apiName];
        if (fieldType === undefined) {
            throw new Error(`Missing FieldID when trying to parse queryString. FieldID: ${apiName}`);
        }
        const values = this.parseValues(expression[operation][1]);
        let operator = undefined;
        switch (fieldType) {
            case 'Bool':
            case 'JsonBool': {
                operator = this.parseBoolOperation(operation, values);
                break;
            }
            case 'Integer':
            case 'Double': {
                operator = this.parseNumberOperation(operation, values);
                break;
            }
            case 'String': {
                operator = this.parseStringOperation(operation, values);
                break;
            }
            case 'Date':
            case 'DateTime': {
                operator = this.parseDateOperation(operation, values);
                break;
            }
            case 'Guid': {
                operator = this.parseBasicExpression(operation, values);
                break;
            }
            default:
                break;
        }
        if (!operator) {
            throw new Error(`Could not parse operator ${operation} with values: ${values} for type: ${fieldType}`);
        }
        const res = {
            ApiName: apiName,
            FieldType: fieldType,
            Operation: operator,
            Values: values,
        };
        return res;
    }
    parseBoolOperation(operator, values) {
        const res = 'IsEqual';
        switch (operator) {
            case '=': {
                break;
            }
            case '!=': {
                // lets swap the value
                const val = converters_1.str2Bool(values[0]);
                values[0] = val ? 'false' : 'true';
                break;
            }
        }
        return res;
    }
    parseBasicExpression(operator, values) {
        let res;
        switch (operator) {
            case '=': {
                res = 'IsEqual';
                break;
            }
            case '!=': {
                res = 'IsNotEqual';
                break;
            }
            case 'IS': {
                const value = values.pop();
                if (value === 'null') {
                    res = 'IsEmpty';
                }
                else if (value === 'not null') {
                    res = 'IsNotEmpty';
                }
                break;
            }
        }
        return res;
    }
    parseNumberOperation(operator, values) {
        let res = this.parseBasicExpression(operator, values);
        if (!res) {
            switch (operator) {
                case '>':
                case '>=':
                case '<=':
                case '<': {
                    res = operator;
                    break;
                }
                case 'IN': {
                    res = 'IsEqual';
                    break;
                }
            }
        }
        return res;
    }
    parseStringOperation(operation, values) {
        let res = this.parseBasicExpression(operation, values);
        if (!res) {
            switch (operation) {
                case 'LIKE': {
                    if (values.length == 1) {
                        let val = values[0];
                        if (val.charAt(0) === '%') {
                            // LIKE '%acbd....
                            if (val.charAt(val.length - 1) === '%') {
                                // LIKE '%acbd%'
                                val = val.slice(1, val.length - 1);
                                res = 'Contains';
                            }
                            else {
                                // LIKE '%acbd'
                                val = val.slice(1, val.length);
                                res = 'EndWith';
                            }
                        }
                        else if (val.charAt(val.length - 1) === '%') {
                            // LIKE 'abcd%'
                            val = val.slice(0, val.length - 1);
                            res = 'StartWith';
                        }
                        else {
                            // LIKE 'abcd'
                            res = 'IsEqual';
                        }
                        values[0] = val;
                    }
                    break;
                }
                case 'IN': {
                    res = 'IsEqual';
                    break;
                }
                case 'NOT IN': {
                    res = 'IsNotEqual';
                    break;
                }
            }
        }
        return res;
    }
    parseDateOperation(operator, values) {
        let res = undefined;
        switch (operator) {
            case '=':
            case '<=':
            case '<':
            case '>=':
            case '>': {
                res = operator;
                break;
            }
            case 'IS': {
                const value = values.pop();
                if (value === 'null') {
                    res = 'IsEmpty';
                }
                else if (value === 'not null') {
                    res = 'IsNotEmpty';
                }
                break;
            }
        }
        return res;
    }
    parseValues(value) {
        let res = [];
        if (typeof value === 'string') {
            res.push(value);
        }
        else if (typeof value === 'number') {
            res.push(value.toString());
        }
        else if (typeof value === 'boolean') {
            res.push(value ? 'true' : 'false');
        }
        else if (value === null) {
            res.push('null');
        }
        else if (typeof value === 'object' && value.NOT && value.NOT[0] === null) {
            res.push('not null');
        }
        else if (Array.isArray(value)) {
            res = value.map((val) => this.parseValues(val)[0]);
        }
        else {
            throw new Error(`Could no parse values from expression: ${value}`);
        }
        return res;
    }
}
exports.SQLWhereParser = SQLWhereParser;
