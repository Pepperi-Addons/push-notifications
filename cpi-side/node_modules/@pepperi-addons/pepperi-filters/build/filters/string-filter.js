"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringFilter = void 0;
const filter_1 = __importDefault(require("./filter"));
const elastic_builder_1 = __importStar(require("elastic-builder"));
class StringFilter extends filter_1.default {
    constructor(apiName, operation, filterValues, caseSensitive = true) {
        super(apiName);
        this.operation = operation;
        this.filterValues = filterValues;
        this.caseSensitive = caseSensitive;
    }
    apply(value) {
        // anything that isn't a string is considered to be an empty value
        const stringVal = typeof value === 'string' ? value : '';
        switch (this.operation) {
            case 'IsEmpty':
                return stringVal === '';
            case 'IsNotEmpty':
                return stringVal !== '';
            case 'IsEqual':
                return this.compare(stringVal);
            case 'IsNotEqual':
                return !this.compare(stringVal);
            case 'Contains':
                return stringVal.toLocaleLowerCase().includes(this.filterValues[0].toLocaleLowerCase());
            case 'StartWith':
                return stringVal.toLocaleLowerCase().startsWith(this.filterValues[0].toLocaleLowerCase());
            case 'EndWith':
                return stringVal.toLocaleLowerCase().endsWith(this.filterValues[0].toLocaleLowerCase());
            case 'IsLoggedInUser':
                throw new Error("IsLoggedInUser isn't a supported filter");
        }
    }
    toSQLWhereClause() {
        switch (this.operation) {
            case 'IsEmpty':
                return `${this.apiName} IS NULL OR ${this.apiName} = ''`;
            case 'IsNotEmpty':
                return `${this.apiName} IS NOT NULL AND ${this.apiName} != ''`;
            case 'IsEqual':
                return `${this.apiName} IN (${this.filterValues.map((str) => `'${str}'`).join(', ')})`;
            case 'IsNotEqual':
                return `${this.apiName} NOT IN (${this.filterValues.map((str) => `'${str}'`).join(', ')})`;
            case 'Contains':
                return `${this.apiName} LIKE '%${this.filterValues[0]}%'`;
            case 'StartWith':
                return `${this.apiName} LIKE '${this.filterValues[0]}%'`;
            case 'EndWith':
                return `${this.apiName} LIKE '%${this.filterValues[0]}'`;
            case 'IsLoggedInUser':
                throw new Error("IsLoggedInUser isn't a supported filter");
        }
    }
    compare(value) {
        if (typeof value !== 'string') {
            return false;
        }
        const first = this.filterValues.find((str) => {
            return (str.localeCompare(value, undefined, {
                sensitivity: this.caseSensitive ? 'case' : 'base',
            }) === 0);
        });
        return first != undefined;
    }
    toKibanaFilter() {
        const res = elastic_builder_1.default.boolQuery();
        const existsFilter = elastic_builder_1.default.existsQuery(this.apiName);
        const termQueryEmpty = elastic_builder_1.default.termQuery(`${this.apiName}`, '');
        const termsQueryValues = elastic_builder_1.default.termsQuery(`${this.apiName}`, this.filterValues.map((val) => val.toString()));
        switch (this.operation) {
            case 'IsEmpty':
                return res.should([elastic_builder_1.default.boolQuery().mustNot(existsFilter), elastic_builder_1.default.boolQuery().must(termQueryEmpty)]);
            case 'IsNotEmpty':
                return res.mustNot(termQueryEmpty).filter(existsFilter);
            case 'IsEqual':
                return res.must(termsQueryValues);
            case 'IsNotEqual':
                return res.mustNot(termsQueryValues);
            case 'Contains':
                return elastic_builder_1.wildcardQuery(this.apiName, `*${this.filterValues[0]}*`);
            case 'StartWith':
                return elastic_builder_1.wildcardQuery(this.apiName, `${this.filterValues[0]}*`);
            case 'EndWith':
                return elastic_builder_1.wildcardQuery(this.apiName, `*${this.filterValues[0]}`);
            case 'IsLoggedInUser':
                throw new Error("IsLoggedInUser isn't a supported filter");
        }
    }
}
exports.StringFilter = StringFilter;
