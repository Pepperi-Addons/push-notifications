"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberFilter = void 0;
const filter_1 = __importDefault(require("./filter"));
const elastic_builder_1 = __importDefault(require("elastic-builder"));
class NumberFilter extends filter_1.default {
    constructor(apiName, operation, filterValues = []) {
        super(apiName);
        this.operation = operation;
        this.filterValues = filterValues;
    }
    apply(value) {
        switch (this.operation) {
            case 'IsEmpty':
                return value == undefined;
            case 'IsNotEmpty':
                return value != undefined;
            case 'IsEqual':
                return this.filterValues.find((x) => value === x) !== undefined;
            case 'IsNotEqual':
                return this.filterValues.find((x) => value === x) === undefined;
            case '=':
                return value === this.filterValues[0];
            case '!=':
                return value !== this.filterValues[0];
            case '>':
                return value > this.filterValues[0];
            case '>=':
                return value >= this.filterValues[0];
            case '<':
                return value < this.filterValues[0];
            case '<=':
                return value <= this.filterValues[0];
            case 'Between':
                return value >= this.filterValues[0] && value <= this.filterValues[1];
        }
    }
    toSQLWhereClause() {
        switch (this.operation) {
            case 'IsEmpty':
                return `${this.apiName} IS NULL`;
            case 'IsNotEmpty':
                return `${this.apiName} IS NOT NULL`;
            case 'IsEqual':
                return `${this.apiName} IN (${this.filterValues.map((val) => val.toString()).join(', ')})`;
            case 'IsNotEqual':
                return `${this.apiName} NOT IN (${this.filterValues.map((val) => val.toString()).join(', ')})`;
            case '=':
                return `${this.apiName} = ${this.filterValues[0]}`;
            case '!=':
                return `${this.apiName} != ${this.filterValues[0]}`;
            case '>':
                return `${this.apiName} > ${this.filterValues[0]}`;
            case '>=':
                return `${this.apiName} >= ${this.filterValues[0]}`;
            case '<':
                return `${this.apiName} < ${this.filterValues[0]}`;
            case '<=':
                return `${this.apiName} <= ${this.filterValues[0]}`;
            case 'Between':
                return `${this.apiName} >= ${this.filterValues[0]} AND ${this.apiName} <= ${this.filterValues[0]}`;
        }
    }
    toKibanaFilter() {
        const existsFilter = elastic_builder_1.default.existsQuery(`${this.apiName}`);
        const termQueryValue = elastic_builder_1.default.termQuery(`${this.apiName}`, this.filterValues[0]);
        const rangeQuery = elastic_builder_1.default.rangeQuery(`${this.apiName}`);
        const termsQueryValues = elastic_builder_1.default.termsQuery(`${this.apiName}`, this.filterValues.map((val) => val.toString()));
        const res = elastic_builder_1.default.boolQuery();
        switch (this.operation) {
            case 'IsEmpty':
                return res.mustNot(existsFilter);
            case 'IsNotEmpty':
                return res.must(existsFilter);
            case 'IsEqual':
                return res.must(termsQueryValues);
            case 'IsNotEqual':
                return res.mustNot(termsQueryValues);
            case '=':
                return res.must(termQueryValue);
            case '!=':
                return res.mustNot(termQueryValue);
            case '>':
                return rangeQuery.gt(this.filterValues[0]);
            case '>=':
                return rangeQuery.gte(this.filterValues[0]);
            case '<':
                return rangeQuery.lt(this.filterValues[0]);
            case '<=':
                return rangeQuery.lte(this.filterValues[0]);
            case 'Between':
                return rangeQuery.lte(this.filterValues[0]).gte(this.filterValues[0]);
        }
    }
}
exports.NumberFilter = NumberFilter;
